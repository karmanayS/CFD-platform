// check the last route in the http server for signup and signin
// subscribe to eth stream and get its decimal
// use queues instead of pubsub in the poller 
// check whether my approach for setInterval 100 ms was correct
//whether to add close orders in inmemory-db
// add leverage margin feature everywhere
//create user logic in the engine(with default ballance values) when hitting the signup endpoint
//short selling logic pending 
//amount shouldnt be sent  by user , it should be calculated on the engine while creating an open order
//check whether the while loop is correct in engine because in real world multiple orders would be placed and the while loop might work how its supposed to but still check 
//maybe store users etc in db 
//remove order from open orders in close order function and also in liqquidation function;
//send a message to the client if the order has been liquidated
//test liquidation using dummy prices
//order value component returns assuming there are only 2 asssets but it should return dynamically and also all other places which assume only 2 assets should be dynamic
//import common types from a single place and dont define them again and again
//in dashboard the dropdown to select the current asset should also be dynamically generated by hitting the api and not hardcoded
//userId is hardcoded in the frontend req , make the signup sgnin and user auth logic properly
//redis doesnt work because it is retaining data i guess fix that
//check whether all the http routes are being used on the frontend

//OPTIMISATIONS:
//instead of again and again writing the same queue reding logic for userId ,make a function for it if can be made